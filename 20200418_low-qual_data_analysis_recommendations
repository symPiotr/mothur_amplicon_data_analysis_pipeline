# ...... just starting .....


##### In the latest data run --- /mnt/matrix/symbio/raw_data/20200324_MiSeq_rerun/ (MiSeq v3 2x260 bp) --- we ended up with suboptimal data:
#   >>> much fewer reads than expected
#   >>> low quality of the second read

##### Most amplicon libraries in that run comprised both COI (primers BF3-BR2) and 16S v4 (515F-806R) products.
I have split them into files corresponding to different products (script to be published). See /mnt/matrix/symbio/temp/ for data corresponding to different projects.

### Below, I am providing commands/suggestions for data analysis, modified relative to my original protocol.



########## The analysis of the COI data. I recommend working on files 
### Start from copying 

get.current()
make.file(inputdir=., type=fastq, prefix=DIC)
make.contigs(file=DIC.file)
trim.seqs(fasta=DIC.trim.contigs.fasta, oligos=/mnt/matrix/symbio/db/references/primers_to_trim.oligos, minlength=250, maxlength=500, maxambig=0, maxhomop=10, pdiffs=2)
list.seqs(fasta=DIC.trim.contigs.trim.fasta)
get.seqs(accnos=DIC.trim.contigs.trim.accnos, group=current)
summary.seqs(fasta=DIC.trim.contigs.fasta, processors=32)
count.groups(group=DIC.contigs.pick.groups)
count.groups(group=DIC.contigs.groups)
unique.seqs(fasta=DIC.trim.contigs.trim.fasta)
count.seqs(name=DIC.trim.contigs.trim.names, group=DIC.contigs.pick.groups, compress=f)


get.current()
split.abund(fasta=DIC.trim.contigs.trim.unique.fasta, count=DIC.trim.contigs.trim.count_table, cutoff=1)
align.seqs(fasta=DIC.trim.contigs.trim.unique.abund.fasta, reference=DICreference.fas)
      ### reference: a COI sequence of a single planthopper, with single gaps introduced every 50 or so bases.
screen.seqs(fasta=DIC.trim.contigs.trim.unique.abund.align, count=DIC.trim.contigs.trim.abund.count_table, minlength=400)
filter.seqs(fasta=DIC.trim.contigs.trim.unique.abund.good.align,vertical=T, trump=.)


rename.file(fasta=current, count=current, prefix=DIC_DIC)
dist.seqs(fasta=DIC_DIC.fasta, cutoff=0.1)
cluster(column=current, count=DIC_DIC.count_table, cutoff=0.03)
bin.seqs(list=DIC_DIC.opti_mcc.list, fasta=DIC_DIC.fasta, label=0.03)
make.shared(list=DIC_DIC.opti_mcc.list, count=DIC_DIC.count_table, label=0.03)

####################################################
### MOTHUR: 16S data - alignments, OTU picking.. ###

### Align 16S sequences against a SILVA db
align.seqs(fasta=ML.trim.contigs.trim.unique.abund.fasta, reference=/mnt/matrix/symbio/db/silva.seed_v132.align, processors=20)

### Get sequence alignment info!
summary.seqs(fasta=ML.trim.contigs.trim.unique.abund.align)

### Remove unaligned
screen.seqs(fasta=ML.trim.contigs.trim.unique.abund.align, count=ML.trim.contigs.trim.abund.count_table, start=13862, end=23444, minlength=220)

### Remove gaps
filter.seqs(fasta=current, vertical=T, trump=.)

### Redo unique.seqs
unique.seqs(fasta=ML.trim.contigs.trim.unique.abund.good.filter.fasta, count=ML.trim.contigs.trim.abund.good.count_table)
    # ML.trim.contigs.trim.unique.abund.good.filter.count_table
    # ML.trim.contigs.trim.unique.abund.good.filter.unique.fasta


### Identify and remove chimaeric sequences using UChime
chimera.uchime(fasta=ML.trim.contigs.trim.unique.abund.good.filter.unique.fasta, reference=self, count=ML.trim.contigs.trim.unique.abund.good.filter.count_table, dereplicate=f, mindiv=0.35, processors=20, minh=0.5, xn=3)
remove.seqs(accnos=current, fasta=current, count=current)


### Classify the sequences by taxonomy
classify.seqs(fasta=current, count=current, reference=/mnt/matrix/symbio/db/silva.seed_v132.align, taxonomy=/mnt/matrix/symbio/db/silva.seed_v132.tax, cutoff=80)

remove.lineage(fasta=current, count=current, taxonomy=current, taxon=Chloroplast-Mitochondria-Archaea-Eukaryota)

summary.tax(taxonomy=current, count=current)

### Simplify file names
rename.file(fasta=current, count=current, taxonomy=current, prefix=ML_16S)

### Compute distance matrix, cluster, construct summary tables
dist.seqs(fasta=ML_16S.fasta, processors=24, cutoff=0.05)
cluster(column=current, count=ML_16S.count_table, cutoff=0.03, method=opti)
bin.seqs(list=current, fasta=current, label=0.03)
make.shared(list=current, count=current, label=0.03)


### Classifying OTUs
classify.otu(list=current,count=current,taxonomy=current, label=0.03)

### Extracting representative sequences
get.oturep(column=current, list=current, fasta=current, count=current, cutoff=0.01)
